
#include "../testTools.h"
#include "../../DFPSR/base/format.h"

START_TEST(Format)
	{
		Buffer data = buffer_create(8);
		SafePointer<uint8_t> bytes = buffer_getSafeData<uint8_t>(data, "Integer encoding buffer");
		format_writeU16_LE(bytes, 0);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0);
		format_writeU16_LE(bytes, 1);
		ASSERT_EQUAL(format_readU16_LE(bytes), 1);
		format_writeU16_LE(bytes, 65534);
		ASSERT_EQUAL(format_readU16_LE(bytes), 65534);
		format_writeU16_LE(bytes, 65535);
		ASSERT_EQUAL(format_readU16_LE(bytes), 65535);
		format_writeI16_LE(bytes, -1);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0b1111111111111111u);
		ASSERT_EQUAL(format_readI16_LE(bytes), -1);
		format_writeI16_LE(bytes, -2736);
		ASSERT_EQUAL(format_readI16_LE(bytes), -2736);
		format_writeI16_LE(bytes, -32767);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0b1000000000000001u);
		ASSERT_EQUAL(format_readI16_LE(bytes), -32767);
		format_writeI16_LE(bytes, -32768);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0b1000000000000000u);
		ASSERT_EQUAL(format_readI16_LE(bytes), -32768);
		format_writeI16_LE(bytes, 0);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0b0000000000000000u);
		ASSERT_EQUAL(format_readI16_LE(bytes), 0);
		format_writeI16_LE(bytes, 1);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0b0000000000000001u);
		ASSERT_EQUAL(format_readI16_LE(bytes), 1);
		format_writeI16_LE(bytes, 375);
		ASSERT_EQUAL(format_readI16_LE(bytes), 375);
		format_writeI16_LE(bytes, 7216);
		ASSERT_EQUAL(format_readI16_LE(bytes), 7216);
		format_writeI16_LE(bytes, 32766);
		ASSERT_EQUAL(format_readI16_LE(bytes), 32766);
		format_writeI16_LE(bytes, 32767);
		ASSERT_EQUAL(format_readU16_LE(bytes), 0b0111111111111111u);
		ASSERT_EQUAL(format_readI16_LE(bytes), 32767);
	}
	// TODO: Test 32 and 64 bit reading and writing.
	{
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b00000000000000000000000000000000u), 0.0f);
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b01000000101000000000000000000000u), 5.0f);
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b01000001001000000000000000000000u), 10.0f);
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b01000001101000000000000000000000u), 20.0f);
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b11000000101000000000000000000000u), -5.0f);
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b11000001001000000000000000000000u), -10.0f);
		ASSERT_NEAR(format_bitsToF32_IEEE754(0b11000001101000000000000000000000u), -20.0f);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b0000000000000000000000000000000000000000000000000000000000000000u),   0.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b0100000000010100000000000000000000000000000000000000000000000000u),   5.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b0100000000100100000000000000000000000000000000000000000000000000u),  10.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b0100000000110100000000000000000000000000000000000000000000000000u),  20.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b0100000001000100000000000000000000000000000000000000000000000000u),  40.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b1100000000010100000000000000000000000000000000000000000000000000u),  -5.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b1100000000100100000000000000000000000000000000000000000000000000u), -10.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b1100000000110100000000000000000000000000000000000000000000000000u), -20.0);
		ASSERT_NEAR(format_bitsToF64_IEEE754(0b1100000001000100000000000000000000000000000000000000000000000000u), -40.0);
	}
END_TEST
