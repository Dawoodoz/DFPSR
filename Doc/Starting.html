<!DOCTYPE html> <HTML lang=en> <HEAD> <STYLE>
body { background-color: #EEFFEE;  font-size: 1.0rem; font-family: Arial; max-width: 60rem;
      color: #000000; margin: 0px;
      padding-left:  0px; padding-right:  0px; padding-top:  0px; padding-bottom:  0px; }
H1 {  padding-left: 10px; padding-right:  0px; padding-top: 10px; padding-bottom: 10px; font-size: 1.4rem; }
H2 {  padding-left: 10px; padding-right:  0px; padding-top: 10px; padding-bottom:  0px; font-size: 1.2rem; }
blockquote {
  tab-size: 3rem;
  color: #88FF88; background: #000000;
  font-size: 0.95rem; font-family: monospace;
  padding-left: 5px; padding-right: 5px;
  padding-top: 5px; padding-bottom: 5px;
}
P {   padding-left: 20px; padding-right:  0px; padding-top:  0px; padding-bottom:  0px; }
IMG { padding-left:  0px; padding-right:  0px; padding-top:  2px; padding-bottom:  0px;
      max-width: 100%; }
A { display: inline; border-radius: 4px;
    font-size: 1.0rem; font-family: Arial; color: #000044; text-decoration: none;
    padding-left: 4px; padding-right: 4px; padding-top: 4px; padding-bottom: 4px; }
A:hover { color: #FFFF00; background: #000044; }
A:active { color: #FFFFFF; background: #444444; }
</STYLE> </HEAD> <BODY>
<IMG SRC="Images/Title.png" ALT="Images/Title.png">
<P>
<A href="Manual.html">Back to main page</A>
</P><P>
</P><H1> Getting started</H1><P>
</P><P>
There are many ways to compile the examples using C++14, but the simplest way to check that everything works, is to build the wizard application and let it build all the other projects before letting you test them.

</P><P>
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Minimum system requirements</H2><P>
</P><P>
<IMG SRC="Images/SmallDot.png">
1 GHz single-core ARMv6 CPU is enough for low-resolution realtime 2D graphics, passive interfaces and grayscale robotic vision, without any SIMD.

</P><P>
<IMG SRC="Images/SmallDot.png">
1.4 GHz quad-core ARMv8 CPU is enough for medium-resolution realtime 2D graphics, using ARM NEON.

</P><P>
<IMG SRC="Images/SmallDot.png">
3 GHz quad-core Intel/AMD CPU with SSE2 is enough for high resolution 2D/isometric/3D graphics with advanced light effects.

</P><P>
<IMG SRC="Images/SmallDot.png">
4 GHz hexa-core Intel/AMD CPU is enough to not notice that the 3D graphics is software rendered.
Enabling SSSE3 (-mssse3) can give a performance boost in image processing and shading to textures by making vector extraction faster.
Enabling AVX2 (-mavx2) can make texture sampling faster by enabling the gather instructions and 256-bit integer operations.

</P><P>
<IMG SRC="Images/SmallDot.png">
Windows XP (from year 2001) is the oldest supported version of MS-Windows because CreateProcessW is used to start other applications.
The file API also assumes access to Unicode versions of functions from Windows 2000.

</P><P>
<IMG SRC="Images/SmallDot.png">
Big-endian support is only theoretical and has never actually been tested, because big-endian desktops were practically extinct when the library was created. If you happen to own such a rare museum item in working condition, sending the <B>DSR_BIG_ENDIAN</B> macro to compilation should activate the big-endian mode and shift the direction of bit shifts that are meant to be equivalent with the address space.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Buliding the wizard application on Linux</H2><P>
</P><P>
<IMG SRC="Images/Warning.png" ALT="Warning">
Linux has many different ways to create a window, so you might need to write a new window manager and add its dependencies to Source/DFPSR/DFPSR.DsrHead if new Linux distributions are not compatible.

</P><P>
<IMG SRC="Images/Warning.png" ALT="Warning">
Light-weight Linux distributions (such as Linux Mint) might require you to install GNU's compiler toolchain <B>"gcc"</B>, X11 developer libraries <B>"libx11-dev"</B> and Alsa developer libraries <B>"libasound2-dev"</B>.

</P><P>
On Debian based systems:
<PRE><BLOCKQUOTE>sudo apt install gcc
sudo apt install libx11-dev
sudo apt install libasound2-dev</BLOCKQUOTE></PRE>

</P><P>
<IMG SRC="Images/SmallDot.png">
Go to the Source\tools\wizard folder in a terminal.

</P><P>
<IMG SRC="Images/SmallDot.png">
Give permission to execute the build script.
<PRE><BLOCKQUOTE>chmod +x build_linux.sh</BLOCKQUOTE></PRE>

</P><P>
<IMG SRC="Images/SmallDot.png">
Run the build script.
<PRE><BLOCKQUOTE>./build_linux.sh</BLOCKQUOTE></PRE>
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Buliding the wizard application on Windows</H2><P>
</P><P>
<IMG SRC="Images/SmallDot.png">
Download and install a mingw edition of CodeBlocks from their website. <A href="http://www.codeblocks.org/downloads/26#windows">www.codeblocks.org/downloads</A>
This is the easiest way to install GNU's C++ compiler g++ on Windows, but CodeBlocks can also be used as a debugger if you create a project with the same source code, backends and compiler flags.

</P><P>
<IMG SRC="Images/SmallDot.png">
Open sysdm.cpl - Advanced - System variables - Path.
Append your path to the folder containing g++.exe so that writing g++ in cmd.exe finds g++.exe.
If you for example installed it at C:\CodeBlocks\MinGW\bin\g++.exe, you add C:\CodeBlocks\MinGW\bin; after the previous ; at the end of Path.

</P><P>
<IMG SRC="Images/SmallDot.png">
Open CMD.exe, go to the Source\tools\wizard folder and execute build_windows.bat from the same folder.
This makes sure that the build system can be found using relative paths.

</P><P>
<IMG SRC="Images/SmallDot.png">
Be patient while building the Builder build system.
The Wizard.DsrProj build script will then build all SDK examples and templates, before launching the Wizard application that lets you browse and run examples.

</P><P>
<IMG SRC="Images/SmallDot.png">
Make sure to manually erase object files in your temporary folder once in a while, because the build system in Source/tools/builder keeps everything for maximum build speed.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Buliding the wizard application on MacOS</H2><P>
</P><P>
<IMG SRC="Images/SmallDot.png">
Go to the Source\tools\wizard folder in a terminal.

</P><P>
<IMG SRC="Images/SmallDot.png">
Give permission to execute the build script.
<PRE><BLOCKQUOTE>chmod +x build_macos.sh</BLOCKQUOTE></PRE>

</P><P>
<IMG SRC="Images/SmallDot.png">
Run the build script.
<PRE><BLOCKQUOTE>./build_macos.sh</BLOCKQUOTE></PRE>

</P><P>
If asked to install development tools during this process, accept to have a C++ compiler installed.

</P><P>
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Create a new project project using the wizard application</H2><P>
</P><P>
The easiest way to create a new application is to use the wizard application that you compiled according to the instructions above.

</P><P>
<IMG SRC="Images/SmallDot.png">
Select a project that you want to use as a template.

</P><P>
<IMG SRC="Images/SmallDot.png">
Press the clone button.

</P><P>
<IMG SRC="Images/SmallDot.png">
Enter the path for your new project as the target path. The new project should ideally be placed right next to the DFPSR folder, so that you can easily preserve the relative paths across computers and see the folder containing a specific version of the DFPSR library and the projects depending on it as a time capsule.

</P><P>
<IMG SRC="Images/SmallDot.png">
Press "Begin cloning" to copy the template and attempt to update relative paths.

</P><P>
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Create a new project manually</H2><P>
</P><P>
<IMG SRC="Images/SmallDot.png">
Copy the folder of a template program to where you want it.
If you want a 3D application with animations, start from basic3D.
If you want graphical user interface that only redrawns when something happens, start from basicGUI.
If you want a command line interface application, start from basicCLI to only depend on the most essential parts of the library.

</P><P>
<IMG SRC="Images/SmallDot.png">
For easy building on new computers with relative paths, you can either place the whole software renderer next to your projects, or just a symbolic link to it as if the library exists at multiple locations.
Then just copy the whole folder structure with all your projects when making backups and you will only have to install any missing tools and give access permissions next time you get started.

</P><P>
<IMG SRC="Images/SmallDot.png">
Update the relative paths to tools/builder/buildProject.sh in build_linux.sh and tools\builder\buildProject.bat in build_windows.bat.
These paths are relative to the folder that you will stand in when calling build_linux.sh or build_windows.bat, but the convention is to call these from where they are located.
Note the differences in path separators with / on Posix systems and \ on Windows.

</P><P>
<IMG SRC="Images/SmallDot.png">
Update the relative path to DFPSR.DsrHead, where you import it in your DsrProj build script.
The paths for importing *.DsrHead are relative to the folder where the importing *.DsrProj file is stored, just like includes in C++.

</P><P>
<IMG SRC="Images/SmallDot.png">
Update relative include paths to includeFramework.h, includeEssentials.h and other headers from the new folder location.
If you have a lot of includes referring directly to the framework in a large project, you can create a new header including includeFramework.h once for all your source files.

</P><P>
<IMG SRC="Images/SmallDot.png">
Making some changes in main.cpp and try building your new project on the targeted operating systems.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Create a shortcut on Linux</H2><P>
</P><P>
There are two types of shortcuts on Linux, symbolic links which are used to make a folder appear on two locations and *.desktop files.
For a shortcut to a program, you will create a *.desktop file because it allows you to select an icon and which folder to execute the application from, so that your media files can be found using relative paths.
On some Linux distributions, you can just right click on the desktop, select that you want to create a program starter and fill in the information.

</P><P>
If you are making an installer however, you might want to automatically generate the desktop file with the .desktop extension using the installation path given by the user.
<PRE><BLOCKQUOTE>[Desktop Entry]
Version=1.0
Type=Application
Name=ShortcutName
Comment=
Exec=/pathToProgram/program
Icon=theProgramsIcon
Path=/pathToProgram
Terminal=false
StartupNotify=false
</BLOCKQUOTE></PRE>
</P><P>
You can also begin your main function with file_setCurrentPath(file_getApplicationFolder()); to move into the application's folder automatically, which is supported on both Windows and Linux, but not guaranteed to work on all Posix systems because the symbolic link /proc/self/exe is not a part of the Posix standard.
</P>
</BODY> </HTML>
