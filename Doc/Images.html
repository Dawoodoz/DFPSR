<!DOCTYPE html> <HTML lang=en> <HEAD> <STYLE>
body { background-color: #EEFFEE; font-size: 16px; font-family: Arial;
       color: #000000; margin: 0px;
       padding-left: 0px; padding-right: 0px;
       padding-top: 0px; padding-bottom: 0px; }
H1 { padding-left: 10px; padding-top: 10px; padding-bottom: 10px; font-size: 26px; }
H2 { padding-left: 10px; padding-top: 10px;  font-size: 20px; }
blockquote {
  color: #FFFFFF; background: #000000;
  font-size: 20px; font-family: monospace;
  padding-left: 5px; padding-right: 5px;
  padding-top: 5px; padding-bottom: 5px;
}
P { padding-left: 10px; }
IMG { padding-left: 0px; padding-right: 0px;
       padding-top: 0px; padding-bottom: 0px; }

A { font-size: 18px; font-family: Arial; color: #0000A0; text-decoration: none; }
A:hover { color: #000070; background: #AAffAA; }
A:active { color: #00A0A0; }
.normal { font-size: 18px; color: #00A0A0; }
.sub { font-size: 18px; color: #ffffdf; }

</STYLE> </HEAD> <BODY>
<IMG SRC="Images/Title.png" ALT="Images/Title.png">
<P>
<A href="Manual.html">Back to main page</A>
</P><P>
</P><H1> Images</H1><P>All image types are passed using reference counted handles so that they are automatically cleaned up when the last handle is freed.
This does add a little allocation overhead compared to having them as value types, but generating mip-map pyramids require a unique identity to prevent aliasing.
If a method doesn't allow the image handle to be null, it will give you a run-time warning about it in debug mode.
You won't have to worry about if the image is a value, reference, raw pointer, shared pointer or unique, because it's always the same type of handle.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> ImageU8</H2><P>The most basic image format used for 8-bit gray-scale images using 0 for black and 255 for white.
Can be displayed by drawing it using draw_copy onto a color image for automatic conversion.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> ImageU16</H2><P>If 8-bit precision is not enough but you still want the determinism of using integers, there's also a 16-bit monochrome image.
Just like 8-bit images, the visible range is 0 to 255 when converting automatically, but the 16-bit image has a higher range up to 65535 (2¹⁶ - 1).
</P><IMG SRC="Images/Border.png"><P>
</P><H2> ImageF32</H2><P>32-bit floating-point images offer more flexibility for advanced image filtering, but does not have the same determinism as integer formats.
Avoid exact equality comparisons using floating-point numbers, because it's always an approximation and the rounding method may differ between CPU models.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> ImageRgbaU8</H2><P>A 32-bit color image format using 4 channels with 8 bits in each. The alpha channel can be used to represent opacity or any other information needed.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Aligned images</H2><P>Then there's the aligned image types AlignedImageU8, AlignedImageU16, AlignedImageF32 and AlignedImageRgbaU8.
Aligned images are created from the constructors by default because new images are always aligned for 128-bit SIMD vectorization.
Non-aligned images are created as sub-images pointing to existing pixel buffers without cloning.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Ordered images</H2><P>The ordered image type OrderedImageRgbaU8 is aligned just like AlignedImageU8 but also ensures that
the pack order is RGBA on every platform, which makes it easy to manuipulate using pointers.
AlignedImageRgbaU8 can however be dynamically set to different internal pack orders using the
constructor image_create_RgbaU8_native, which is used by the window's canvas.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Loading images</H2><P>image_load_RgbaU8 can be used to load an RGBA image from a file.
If you only need one channel, then use image_get_red on the result to extract the first channel from a gray-scale image.
</P><IMG SRC="Images/Border.png"><P>
</P><H2> Saving images</H2><P>image_save can be used to save an RGBA image to a file.
</P><IMG SRC="Images/Border.png"><P>
</P>
</BODY> </HTML>
