<- Manual.html | Back to main page

Title: Design principles

---

Title2: Choice of C++ instead of C

The original version of DFPSR was written in the C language, in an attempt to keep it simple and have a stable ABI for dynamic linking with almost any language.
Being a graphics API instead of a graphics engine however, the pre-existing image filters would have made very boring graphics.
So dynamic linking was not an option and then it did not matter if the ABI was stable or not when compiling all source code in the same version of the same language.
Any mistake in handling of resources when writing all applications in C would lead to memory corruption, so development was painfully slow when trying to throw together a quick prototype.
The library needed a language that allowed writing both realtime image filters with pointers, and the high level abstractions needed to apply bound checks on those pointers in debug mode.

While not perfect, C++ 2014 filled most of the requirements, by having access to both low level optimization and high level abstractions.
With dsr::SafePointer, there were no more random memory crashes of unknown origin, because bound checked pointers caught data corruption directly where it happened in debug mode.
With RAII, memory leaks no longer happened from having allocations with no pointers to them, only from applications deciding to keep adding things to collections without ever removing them.
The SIMD abstraction used operator overloading instead of named functions for everything, which made complex math expressions a lot more readable.

---

Title2: Relying on a language standard instead of a single compiler implementation

What if the library had used a language with a single compiler implementation to fully specify the behavior?
If the interpretation of your code requires reading the source code of a specific compiler to understand what it is supposed to do, that code will die with the compiler.
Once the source code stands on its own without a compiler that still runs on modern systems, avoiding undefined behavior must be done in the code itself.

---

Title2: Bundling transpilers with projects

Relying on a transpiler that is bundled with the project is however fine, because you can generate code that avoids undefined behavior and save the output in case that the transpiler can no longer execute.
This documentation was generated using a transpiler, so that it does not rely on the ability to parse HTML.

---
